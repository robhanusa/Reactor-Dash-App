# -*- coding: utf-8 -*-
"""
Created on Wed May 17 09:30:04 2023

@author: rhanusa
"""
import numpy as np
from plotly.subplots import make_subplots
import plotly.graph_objects as go
from plant_components import Battery, Reactor1, Reactor2, pph
from weather_energy_components import Hourly_state, battery_max, data_length
import math

graph_margin = dict(b=60, l=20, r=20, t=60)

# How fast r1 gets saturated per mol COS produced
r1_sat_factor = 5

r1_clean_speed = 10

# Sx filter saturation speed
sx_sat_factor = 3

# Length of graphs' x axes.
idle_start_length = 500
x = [i*60/pph for i in range(-idle_start_length,1)]

num_periods = data_length*pph + idle_start_length

# Create arrays to store all calculated data that will be displayed.
# This helps minimize the calculations occuring in the callback function and
# lets the dashboard update more smoothly
r1_cos_out = np.zeros(num_periods)
r2_sx_out = np.zeros(num_periods)
r1_e = np.zeros(num_periods)
r2_e = np.zeros(num_periods)
generated_kw = np.zeros(num_periods)
consumed_kw = np.zeros(num_periods)
battery_charge = [50]*(num_periods)
kw_to_battery_arr = np.zeros(num_periods)
r_1_1_sat = np.zeros(num_periods)
r_1_2_sat = np.zeros(num_periods)
r_1_3_sat = np.zeros(num_periods)
sx_sat = np.zeros(num_periods)
sx_filter_changes = np.zeros(num_periods)
r1_changovers = np.zeros(num_periods)
r1_1_state = ["idle"]*(num_periods)
r1_2_state = ["idle"]*(num_periods)
r1_3_state = ["idle"]*(num_periods)

# Initiate necessary variables
r1_prev = 0 
r2_prev = 0 
sx_sat_prev = 0
reactor1_1 = Reactor1()
reactor1_2 = Reactor1()
reactor1_1.state = "active"
reactor2 = Reactor2()
battery = Battery(50)

# Calcuate the energy generated by wind and solar
def calc_generated_kw():
    return state.wind_power/pph + state.solar_power/pph

# Need to adjust so COS produced = COS consumed
def distribute_energy(period):
    energy_generated = generated_kw[period]
    energy_stored = battery.charge
    r1_max = 1
    r1_min = 0.05
    r2_max = 4
    r2_min = 1
    
    # Check if there has already been a change in energy distribution in the last
    # hour. If so, don't change current distribution.
    if len(set(r1_e[period - pph : period])) > 1:
        to_r1 = r1_e[period-1]
        to_r2 = r2_e[period-1]
    elif energy_stored + energy_generated < r2_min + r1_min or energy_stored/battery_max < 0.10:
        to_r1 = 0
        to_r2 = 0
    elif energy_stored/battery_max < 0.30:
        to_r1 = 0.5
        to_r2 = 1
    elif energy_stored/battery_max < 0.50:
        to_r1 = .7
        to_r2 = 2
    else:
        to_r1 = r1_max
        to_r2 = r2_max
        
    to_battery = energy_generated - to_r1 - to_r2

    return to_r1, to_r2, to_battery

def battery_charge_differential(period):
    return e_to_battery * battery.efficiency / pph

def update_reactor_1(period, r1_prev):
    if reactor1_1.state == "active":
        r1_cos_current = reactor1_1.react(r1_e_current, r1_prev) 
        reactor1_1.saturation += r1_cos_current / pph * r1_sat_factor
        if reactor1_1.saturation >= 100:
            reactor1_1.saturation -= r1_cos_current / pph * r1_sat_factor
            reactor1_1.state = "cleaning"
            reactor1_2.state = "active"
            r1_changovers[period] = r1_changovers[period - 1] + 1
        else:
            r1_changovers[period] = r1_changovers[period - 1]
            
    elif reactor1_2.state == "active":
        r1_cos_current = reactor1_2.react(r1_e_current, r1_prev) 
        reactor1_2.saturation += r1_cos_current/pph*r1_sat_factor
        if reactor1_2.saturation >= 100:
            reactor1_2.saturation -= r1_cos_current/pph*r1_sat_factor
            reactor1_2.state = "cleaning"
            reactor1_1.state = "active"
            r1_changovers[period] = r1_changovers[period - 1] + 1
        else:
            r1_changovers[period] = r1_changovers[period - 1]
            
    # Update arrays containing reactor states
    r1_1_state[period] = reactor1_1.state
    r1_2_state[period] = reactor1_2.state
    
    # Update arrays for r1 
    r1_cos_out[period] = r1_cos_current
    r1_e[period] = r1_e_current
    r1_prev = r1_cos_current
    # Switch state from 'cleaning' to 'idle' when reactor is clean
    if reactor1_2.state == "cleaning":
        reactor1_2.saturation = max(0, reactor1_2.saturation - r1_clean_speed/pph)
        if reactor1_2.saturation == 0: reactor1_2.state = "idle"
        
    if reactor1_1.state == "cleaning":
        reactor1_1.saturation = max(0, reactor1_1.saturation - r1_clean_speed/pph)
        if reactor1_1.saturation == 0: reactor1_1.state = "idle"
    
    r_1_1_sat[period] = reactor1_1.saturation
    r_1_2_sat[period] = reactor1_2.saturation
            
    return r1_prev

# Update Sx filter saturation and tally filter changes
def update_sx_filter(period, sx_sat_prev):
    sx_sat_current = sx_sat_prev + r2_sx_current/pph*sx_sat_factor
    if sx_sat_current < 100:
        sx_sat[period] = sx_sat_current
        sx_sat_prev = sx_sat_current
        sx_filter_changes[period] = sx_filter_changes[period - 1]
    else:
        sx_sat[period] = 0
        sx_sat_prev = 0
        sx_filter_changes[period] = sx_filter_changes[period - 1] + 1
    
    return sx_sat_prev
    
# Calculate conditions at each hourly state
for hour in range(data_length):
    state = Hourly_state(hour)
    
    # Allow for multiple periods per hour
    for i in range(pph):
        period = hour*pph + i + idle_start_length
            
        # Energy flowing to the plant
        generated_kw[period] = calc_generated_kw()
        
        # Energy distribution for current period
        r1_e_current, r2_e_current, e_to_battery = distribute_energy(period)
        
        # Update battery charge
        battery.charge += e_to_battery * battery.efficiency / pph 
        
        # Update arrays for battery charge, energy consumed by plant, 
        # and energy directed to battery
        battery_charge[period] = battery.charge
        consumed_kw[period] = r1_e_current + r2_e_current
        kw_to_battery_arr[period] = e_to_battery
        
        # Calculate reactor 1 states and tally changeovers
        r1_prev = update_reactor_1(period, r1_prev)
        
        # Calculate reactor 2 state
        r2_sx_current = reactor2.react(r2_e_current, r2_prev)
        r2_sx_out[period] = r2_sx_current
        r2_e[period] = r2_e_current
        r2_prev = r2_sx_current
        
        # Update Sx filter saturation and tally filter changes
        sx_sat_prev = update_sx_filter(period, sx_sat_prev)

# Energy allocation figure
fig_e_allo = make_subplots(rows=1,cols=1,
                           specs=[[dict(secondary_y= True)]])
fig_e_allo.add_trace(go.Scatter(x=[], y=[], mode="lines", 
                                name="Energy produced by renewables"),
                     row=1, col=1, secondary_y=False)
fig_e_allo.add_trace(go.Scatter(x=[], y=[], mode= "lines", 
                                name="Energy allocated to plant"),
                     row=1, col=1, secondary_y=False)
fig_e_allo.add_trace(go.Scatter(x=[], y=[], mode= "lines", 
                                name="Battery charge"),
                     row=1, col=1, secondary_y=True)
fig_e_allo.update_xaxes(title_text="Minutes before present", 
                        range=[-idle_start_length,0],
                        row=1, col=1)
fig_e_allo.update_yaxes(title_text="kW produced/consumed", range=[0,20], 
                        secondary_y=False, row=1, col=1)
fig_e_allo.update_yaxes(title_text="kWh stored in battery", range=[0,100], 
                        secondary_y=True, row=1, col=1)
fig_e_allo.update_layout(title_text="Energy Allocation", title_x=0.5,
                         title=dict(yref="paper",
                                    y=1, 
                                    yanchor="bottom", 
                                    pad=dict(b=20)),
                         legend=dict(yanchor="top", 
                                     xanchor="left", 
                                     y=0.99, 
                                     x=0.01),
                         margin=graph_margin)

# Reactor 1 output figure
fig_r1 = make_subplots(rows=1, cols=1, specs=[[dict(secondary_y= True)]])
fig_r1.add_trace(go.Scatter(x=[], y=[], mode= "lines", name="COS produced"),
                 row=1, col=1, secondary_y=False)
fig_r1.add_trace(go.Scatter(x=[], y=[], mode= "lines", name="Energy input"),
                 row=1, col=1, secondary_y=True)
fig_r1.update_xaxes(title_text="Minutes before present", range=[-500,0],
                          row=1, col=1)
fig_r1.update_yaxes(title_text="mol COS per hour", range=[0,1], 
                    secondary_y=False, row=1, col=1)
fig_r1.update_yaxes(title_text="kW", range=[0,6], 
                    secondary_y=True, row=1, col=1)
fig_r1.update_layout(title_text="H2S + CO2 => COS + H2O", title_x=0.5,
                     title=dict(yref="paper",
                                y=1, 
                                yanchor="bottom", 
                                pad=dict(b=20)),
                     legend=dict(yanchor="top", xanchor="left", y=0.99, x=0.01),
                     margin=graph_margin)

# Reactor 2 output figure
fig_r2 = make_subplots(rows=1,cols=1, specs=[[dict(secondary_y= True)]])
fig_r2.add_trace(go.Scatter(x=[], y=[], mode= "lines", name="Sx produced"),
                     row=1, col=1, secondary_y=False)
fig_r2.add_trace(go.Scatter(x=[], y=[], mode= "lines", name="Energy input"),
                     row=1, col=1, secondary_y=True)
fig_r2.update_xaxes(title_text="Minutes before present", range=[-500,0],
                          row=1, col=1)
fig_r2.update_yaxes(title_text="mol Sx per hour", range=[0,1], 
                    secondary_y=False, row=1, col=1)
fig_r2.update_yaxes(title_text="kW", range=[0,20], 
                    secondary_y=True, row=1, col=1)
fig_r2.update_layout(title_text="COS => CO + Sx", title_x=0.5,
                     title=dict(yref="paper", 
                                y=1, 
                                yanchor="bottom", 
                                pad=dict(b=20)),
                     legend=dict(yanchor="top", xanchor="left", y=0.99, x=0.01),
                     margin=graph_margin)

# Reactor 1 reaction curve figure
r1_rxn_curve_x = np.linspace(0,10,20)
r1_rxn_curve_y= [reactor1_1.ss_output(i) for i in r1_rxn_curve_x]

fig_r1_rxn = make_subplots(rows=1, cols=1)
fig_r1_rxn.add_trace(go.Scatter(x=[], y=[], mode= "lines", 
                                name="R1 reaction curve"), 
                     row=1, col=1)
fig_r1_rxn.add_trace(go.Scatter(x=[], y=[], marker=dict(color="red", size=20),
                                mode="markers", name="Current state"), 
                     row=1, col=1)
fig_r1_rxn.update_xaxes(title_text="kW", range=[0,10],row=1, col=1)
fig_r1_rxn.update_yaxes(title_text="mol COS per hour", range=[0,1.6],
                        row=1, col=1)
fig_r1_rxn.update_layout(title_text="Steady state COS output versus energy", 
                         title_x=0.5,
                         title=dict(yref="paper", 
                                    y=1, 
                                    yanchor="bottom", 
                                    pad=dict(b=20)),
                         legend=dict(yanchor="bottom", 
                                     xanchor="right", 
                                     y=0.02, 
                                     x=0.99),
                         margin=graph_margin)

# Reactor 2 reaction curve figure
r2_rxn_curve_x = np.linspace(0,16,20)
r2_rxn_curve_y= [reactor2.ss_output(i) for i in r2_rxn_curve_x]

fig_r2_rxn = make_subplots(rows=1,cols=1)
fig_r2_rxn.add_trace(go.Scatter(x=[], y=[], mode= "lines", 
                                name="R2 reaction curve"), row=1, col=1)
fig_r2_rxn.add_trace(go.Scatter(x=[], y=[], marker=dict(color="red", size=20),
                                mode="markers", name="Current state"), 
                     row=1, col=1)
fig_r2_rxn.update_xaxes(title_text="kW", range=[0,16], row=1, col=1)
fig_r2_rxn.update_yaxes(title_text="mol Sx per hour", range=[0,1.1], 
                        row=1, col=1)
fig_r2_rxn.update_layout(title_text="Steady state Sx output versus energy", 
                         title_x=0.5,
                         title=dict(yref="paper", 
                                    y=1, 
                                    yanchor="bottom", 
                                    pad=dict(b=20)),
                         legend=dict(yanchor="bottom", 
                                     xanchor="right", 
                                     y=0.02, 
                                     x=0.99),
                         margin=graph_margin)

def update(n_intervals):
    period = n_intervals + idle_start_length
    
    # Energy to battery
    kw_to_battery = kw_to_battery_arr[period]
    
    # Create timestamp
    state = Hourly_state(math.floor(n_intervals/pph))
    time = state.time
    
    # Energy generated by renewables
    kw_gen = generated_kw[period]
    
    # Battery level figure
    bat_lvl_full = battery_charge[period]
    bat_lvl_empty = battery_max - battery_charge[period]
    fig_bat_lvl = go.Figure(data=[go.Bar(x=[1], y=[bat_lvl_full], 
                                         marker_color="green"),
                                  go.Bar(x=[1], y=[bat_lvl_empty],  
                                         marker_color="gray")])
    fig_bat_lvl.update_layout(title_text="Battery Level", 
                              title_x=0.5, title_y=0.96,
                              barmode='stack', paper_bgcolor="rgba(0,0,0,0)",
                              plot_bgcolor='rgba(0, 0, 0, 0)', showlegend=False,
                              margin=dict(l=20, r=20, t=20, b=20), height=200,
                              width=150)
    fig_bat_lvl.update_xaxes(showticklabels=False)
    fig_bat_lvl.update_yaxes(tickmode="array", tickvals=[round(bat_lvl_full)])
    
    # Image for energy flow directions
    if kw_to_battery > 0:
        img_energy_flow = "assets/en_from_wind_to_bat_plant.png"
    elif kw_gen == 0:
        img_energy_flow = "assets/en_from_bat.png"
    else:
        img_energy_flow = "assets/en_from_bat_and_wind.png"
        
    # Image for reactor 1 status's
    if r1_1_state[period] == "active" and \
        r1_2_state[period] == "idle":
            img_r1_status = "assets/1active_2idle_3idle.png"
    elif r1_1_state[period] == "active" and \
        r1_2_state[period] == "cleaning":
            img_r1_status = "assets/1active_2cleaning_3idle.png"
    elif r1_1_state[period] == "cleaning" and \
        r1_2_state[period] == "active":
            img_r1_status = "assets/1cleaning_2active_3idle.png"
    elif r1_1_state[period] == "idle" and \
        r1_2_state[period] == "active":
            img_r1_status = "assets/1idle_2active_3idle.png"
    else:
        img_r1_status = "assets/1idle_2idle_3idle.png"

    # Figure for 1st r1 saturation
    r1_1_saturation = r_1_1_sat[period]
    r1_1_available = 100 - r1_1_saturation
    fig_lvl_r1_1 = go.Figure(data=[go.Bar(x=[1], y=[r1_1_saturation], 
                                          marker_color="aqua"),
                                  go.Bar(x=[1], y=[r1_1_available],  
                                         marker_color="silver")])
    fig_lvl_r1_1.update_layout(title_text="", title_x=0.5, title_y=0.96,
                              barmode='stack', paper_bgcolor="rgba(0,0,0,0)",
                              plot_bgcolor='rgba(0, 0, 0, 0)', showlegend=False,
                              margin=dict(l=20, r=20, t=20, b=20), height=150,
                              width=100)
    fig_lvl_r1_1.update_xaxes(showticklabels=False)
    fig_lvl_r1_1.update_yaxes(tickmode="array", 
                              tickvals=[round(r1_1_saturation)])
    
    # Figure for 2nd r1 saturation
    r1_2_saturation = r_1_2_sat[period]
    r1_2_available = 100 - r1_2_saturation
    fig_lvl_r1_2 = go.Figure(data=[go.Bar(x=[1], y=[r1_2_saturation], 
                                          marker_color="aqua"),
                                  go.Bar(x=[1], y=[r1_2_available], 
                                         marker_color="silver")])
    fig_lvl_r1_2.update_layout(title_text="", title_x=0.5, title_y=0.96,
                              barmode='stack', paper_bgcolor="rgba(0,0,0,0)",
                              plot_bgcolor='rgba(0, 0, 0, 0)', showlegend=False,
                              margin=dict(l=20, r=20, t=20, b=20), height=150,
                              width=100)
    fig_lvl_r1_2.update_xaxes(showticklabels=False)
    fig_lvl_r1_2.update_yaxes(tickmode="array", 
                              tickvals=[round(r1_2_saturation)])
    
    # Figure for 3rd r1 saturation
    r1_3_saturation = r_1_3_sat[period]
    r1_3_available = 100 - r1_3_saturation
    fig_lvl_r1_3 = go.Figure(data=[go.Bar(x=[1], y=[r1_3_saturation], 
                                          marker_color="aqua"),
                                  go.Bar(x=[1], y=[r1_3_available],  
                                         marker_color="silver")])
    fig_lvl_r1_3.update_layout(title_text="", title_x=0.5, title_y=0.96,
                              barmode='stack', paper_bgcolor="rgba(0,0,0,0)",
                              plot_bgcolor='rgba(0, 0, 0, 0)', showlegend=False,
                              margin=dict(l=20, r=20, t=20, b=20), height=150,
                              width=100)
    fig_lvl_r1_3.update_xaxes(showticklabels=False)
    fig_lvl_r1_3.update_yaxes(tickmode="array", 
                              tickvals=[round(r1_3_saturation)])
    
    # Tally for r1 changeovers
    r1_changeover_tally = r1_changovers[period]
    
    # Counter for Sx filter changes
    sx_changeovers = sx_filter_changes[period]
    
    # Figure for Sx filter saturation
    sx_saturation = sx_sat[period]
    sx_available = 100 - sx_saturation
    fig_sx_sat = go.Figure(data=[go.Bar(x=[1], y=[sx_saturation], 
                                        marker_color="yellow"),
                                  go.Bar(x=[1], y=[sx_available], 
                                         marker_color="silver")])
    fig_sx_sat.update_layout(title_text="", title_x=0.5, title_y=0.96,
                              barmode='stack', paper_bgcolor="rgba(0,0,0,0)",
                              plot_bgcolor='rgba(0, 0, 0, 0)', showlegend=False,
                              margin=dict(l=20, r=20, t=20, b=20), height=150,
                              width=100)
    fig_sx_sat.update_xaxes(showticklabels=False)
    fig_sx_sat.update_yaxes(tickmode="array", tickvals=[round(sx_saturation)])
    
    # Update the data on the 5 bottom graphs. Since extendData property is used,
    # only the data is refreshed and not updated.
    # Note that "idle_start_length + 1" is the number of points that is replaced
    # on the graphs for each iteration
    e_allocation = [
        dict(x=[x, x, x], 
             y=[
                 [generated_kw[i] for i in range(n_intervals,period + 1)],
                 [consumed_kw[i] for i in range(n_intervals,period + 1)],
                 [battery_charge[i] for i in range(n_intervals,period + 1)]
               ]
             ),
            [0,1,2], 
            idle_start_length + 1, 
            idle_start_length + 1, idle_start_length + 1]
    
    r1_updates = [
        dict(x=[x, x], 
             y=[
                 [r1_cos_out[i] for i in range(n_intervals,period + 1)],
                 [r1_e[i] for i in range(n_intervals,period + 1)]
               ]
             ),
            [0,1], 
            idle_start_length + 1, 
            idle_start_length + 1]
    
    r2_updates = [
        dict(x=[x, x], 
             y=[
                 [r2_sx_out[i] for i in range(n_intervals,period + 1)],
                 [r2_e[i] for i in range(n_intervals,period + 1)]
               ]
             ),
            [0,1], 
            idle_start_length + 1, 
            idle_start_length + 1] 
    
    r1_rxn_updates = [
        dict(x=[r1_rxn_curve_x, [r1_e[period]]*20], 
             y=[
                 r1_rxn_curve_y,
                 [reactor1_1.ss_output(r1_e[period])]*20
               ]
             ),
            [0,1], 
            20, 
            1]
    
    r2_rxn_updates = [
            dict(x=[r2_rxn_curve_x, [r2_e[period]]*20], 
                 y=[
                     r2_rxn_curve_y,
                     [reactor2.ss_output(r2_e[period])]*20
                   ]
                 ),
                [0,1], 
                20, 
                1]

    return (round(kw_to_battery,2), time.strftime("%d-%m-%Y %H:%M"), 
            fig_bat_lvl, img_energy_flow, round(kw_gen,2), 
            round(r1_e[period],2), round(r2_e[period],2),"X.XX", img_r1_status,
            fig_lvl_r1_1, fig_lvl_r1_2, fig_lvl_r1_3, r1_changeover_tally, 
            sx_changeovers, fig_sx_sat, e_allocation, r1_updates, r2_updates, 
            r1_rxn_updates, r2_rxn_updates)