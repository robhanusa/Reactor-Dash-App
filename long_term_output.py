# -*- coding: utf-8 -*-
"""
Created on Mon Jun 26 08:47:37 2023

@author: rhanusa
"""

''' 
outputs:
    (values)
        Total energy from grid (eventually cost from grid, if we account for tiered pricing)
        Sx produced
        Sx filter changeovers
        r1 changeovers
        
    (Adjustable inputs)
        Capex (how large the battery, how many wind turbines, area of solar panels)
    
    (data for graphs)
        Energy from grid, averaged for each hour, grouped by month
        Sx produced per month
'''
import numpy as np
from plant_components import Battery, Reactor1, Reactor2, Sx_filter, pph
from weather_energy_components import Hourly_state, battery_max, data_length, Energy_flow
#import dashboard_components as dc

# Inputs
battery_specs = { # Using battery at https://www.backupbatterypower.com/products/1-144-kwh-industrial-battery-backup-and-energy-storage-systems-ess-277-480-three-phase?pr_prod_strat=use_description&pr_rec_id=97fba9aea&pr_rec_pid=6561192214696&pr_ref_pid=6561191100584&pr_seq=uniform
    "max_charge": 1144, # kWh
    "cost": 1.2*10**6 
    }

solar_panel_specs = {
    "area": 1000, # m^2
    "efficiency": 0.1,
    "cost": 1000*200/1.1 # $200/m2 (/1.1 eur to usd) https://www.sunpal-solar.com/info/how-much-does-a-solar-panel-cost-per-square-me-72064318.html
    }

wind_turbine_specs = {
    "cut_in": 13, # km/h
    "rated_speed": 50, # km/h
    "cut_out": 100, # km/h
    "max_energy": 1000, # kW
    "count": 1,
    "cost": 1.5*10**6 # EUR/MW (https://www.windustry.org/how_much_do_wind_turbines_cost)
    }

# initialize counters
total_grid = 0 # kw
total_grid_hourly = np.zeros([24,12]) # kw per hour per month
total_renewable = 0 # kw
total_renewable_hourly = np.zeros([24,12]) # kw per hour per month
total_sx = 0 # mol
total_sx_monthly = np.zeros(12)
hour_tally = np.zeros([24,12])
month_tally = np.zeros(12)

# Create arrays to store all calculated data that will be displayed.
# This helps minimize the calculations occuring in the callback function and
# lets the dashboard update more smoothly
sx_sat = 0
sx_filter_tally = 0
r1_changeovers_tally = 0

# Initiate necessary variables
r2_prev = 0 
reactor1_1 = Reactor1()
reactor1_2 = Reactor1()
reactor1_1.state = "active"
reactor2 = Reactor2()
sx_filter = Sx_filter()
battery = Battery(0.5*battery_max, battery_max)
energy_flow = Energy_flow()
energy_tally = pph
r2_e_prev = 0
prev_month = 0
prev_hour = 0

# Necessary constants
r1_sat_factor = reactor1_1.sat_factor
r1_clean_speed = reactor1_1.clean_speed
sx_sat_factor = sx_filter.sat_factor

# # Calcuate the energy generated by wind and solar
# def calc_generated_kw():
#     return state.wind_power/pph + state.solar_power/pph

# def allocate_e_to_condenser(to_r2):
#     condenser_constant = 0.5
#     r2_sx_ss = reactor2.ss_output(to_r2)
#     to_condenser = condenser_constant * r2_sx_ss
#     return to_condenser

# # Need to adjust so COS produced = COS consumed
# def distribute_energy(energy_generated, energy_tally, r2_e_prev):
#     energy_stored = battery.charge
#     r1_max = 0.7
#     r1_min = 0.7
#     r2_max = 4
#     r2_min = 1
    
#     # Check if there has already been a change in energy distribution in the last
#     # hour. If so, don't change current distribution.
#     if energy_tally < pph : 
#         energy_tally += 1
#     elif energy_stored + energy_generated < r2_min + r1_min:
#         energy_flow.to_r1 = r1_min
#         energy_flow.to_r2 = r2_min
#         energy_flow.to_condenser = allocate_e_to_condenser(energy_flow.to_r2)
#         energy_flow.from_grid = r2_min + r1_min - (energy_stored + energy_generated)
#     elif energy_stored/battery_max < 0.30:
#         energy_flow.to_r1 = r1_min
#         energy_flow.to_r2 = r2_min
#         energy_flow.to_condenser = allocate_e_to_condenser(energy_flow.to_r2)
#         energy_flow.from_grid = 0
#     elif energy_stored/battery_max < 0.50:
#         energy_flow.to_r1 = r1_max
#         energy_flow.to_r2 = 2
#         energy_flow.to_condenser = allocate_e_to_condenser(energy_flow.to_r2)
#         energy_flow.from_grid = 0
#     else:
#         energy_flow.to_r1 = r1_max
#         energy_flow.to_r2 = r2_max
#         energy_flow.to_condenser = allocate_e_to_condenser(energy_flow.to_r2)
#         energy_flow.from_grid = 0
    
#     if r2_e_prev != energy_flow.to_r2: energy_tally = 1
    
#     r2_e_prev = energy_flow.to_r2
        
#     if energy_flow.from_grid == 0:
#         energy_flow.to_battery = energy_generated \
#             - energy_flow.to_r1 - energy_flow.to_r2 - energy_flow.to_condenser
#     else:
#         energy_flow.to_battery = 0

#     return energy_tally, r2_e_prev

# def battery_charge_differential(e_to_battery):
#     if e_to_battery > 0:
#         if e_to_battery * battery.efficiency / pph + battery.charge > battery_max:
#             return 0
#         else:
#             return e_to_battery * battery.efficiency / pph
#     else:
#         return e_to_battery / pph

# def update_reactor_1(r2_sx_current, r1_changeovers_tally):
#     if reactor1_1.state == "active":
#         r1_cos_current = reactor1_1.react(r2_sx_current) / 0.9 # Project assumption is 90% conversion rate for r2
#         reactor1_1.saturation += r1_cos_current / pph * r1_sat_factor
#         if reactor1_1.saturation >= 100:
#             reactor1_1.saturation -= r1_cos_current / pph * r1_sat_factor
#             reactor1_1.state = "cleaning"
#             reactor1_2.state = "active"
#             r1_changeovers_tally += 1
            
#     elif reactor1_2.state == "active":
#         r1_cos_current = reactor1_2.react(r2_sx_current) / 0.9 # Project assumption is 90% conversion rate for r2
#         reactor1_2.saturation += r1_cos_current/pph*r1_sat_factor
#         if reactor1_2.saturation >= 100:
#             reactor1_2.saturation -= r1_cos_current/pph*r1_sat_factor
#             reactor1_2.state = "cleaning"
#             reactor1_1.state = "active"
#             r1_changeovers_tally += 1

#     # Switch state from 'cleaning' to 'idle' when reactor is clean
#     if reactor1_2.state == "cleaning":
#         reactor1_2.saturation = max(0, reactor1_2.saturation - r1_clean_speed/pph)
#         if reactor1_2.saturation == 0: reactor1_2.state = "idle"
        
#     if reactor1_1.state == "cleaning":
#         reactor1_1.saturation = max(0, reactor1_1.saturation - r1_clean_speed/pph)
#         if reactor1_1.saturation == 0: reactor1_1.state = "idle"
    
#     return r1_changeovers_tally


# # Update Sx filter saturation and tally filter changes
# def update_sx_filter(sx_sat_current, sx_filter_tally):
#     sx_sat_current = sx_sat_current + r2_sx_current/pph*sx_sat_factor
#     if sx_sat_current >= 100:
#         sx_sat_current = 0
#         sx_filter_tally += 1
    
#     return sx_sat_current, sx_filter_tally
    
# Calculate conditions at each hourly state and store in arrays
for hour in range(data_length):
    state = Hourly_state(hour)
    
    # Allow for multiple periods per hour
    for i in range(pph):
        
        # Energy flowing to the plant
        energy_generated = dc.calc_generated_kw()
        total_renewable += energy_generated/pph
        total_renewable_hourly[state.hour_of_day][state.month-1] += energy_generated/pph
        
        # Energy distribution for current period
        energy_tally, r2_e_prev = dc.distribute_energy(energy_generated, energy_tally, r2_e_prev)
        
        # Update battery charge
        battery.charge += dc.battery_charge_differential(energy_flow.to_battery)
        
        # Calculate reactor 2 state
        r2_sx_current = reactor2.react(energy_flow.to_r2, r2_prev)
        total_sx += r2_sx_current/pph
        r2_prev = r2_sx_current
        total_sx_monthly[state.month-1] += r2_sx_current/pph
        
        # Calculate reactor 1 states and tally changeovers
        r1_changeovers_tally = dc.update_reactor_1(r2_sx_current, r1_changeovers_tally)
        
        # Update Sx filter saturation and tally filter changes
        sx_sat, sx_filter_tally = dc.update_sx_filter(sx_sat, sx_filter_tally)
        
        # Add up energy taken from grid
        total_grid += energy_flow.from_grid/pph
        total_grid_hourly[state.hour_of_day][state.month-1] += energy_flow.from_grid/pph
        
        if prev_hour != state.hour_of_day: hour_tally[state.hour_of_day][state.month-1] += 1
        if prev_month != state.month: month_tally[state.month-1] += 1
        
        prev_hour = state.hour_of_day
        prev_month = state.month

ave_renewable_hourly = total_renewable_hourly / hour_tally
ave_grid_hourly = total_grid_hourly / hour_tally
ave_sx_monthly = total_sx_monthly / month_tally